{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PushToTalkButton = void 0;\n\nvar react_1 = __importStar(require(\"react\"));\n\nvar react_client_1 = require(\"@speechly/react-client\");\n\nvar pubsub_js_1 = __importDefault(require(\"pubsub-js\"));\n\nvar types_1 = require(\"../types\");\n\nvar __1 = require(\"..\");\n\nvar PushToTalkButton = function (_a) {\n  var _b = _a.powerOn,\n      powerOn = _b === void 0 ? false : _b,\n      _c = _a.hide,\n      hide = _c === void 0 ? false : _c,\n      captureKey = _a.captureKey,\n      _d = _a.size,\n      size = _d === void 0 ? '6.0rem' : _d,\n      _e = _a.gradientStops,\n      gradientStops = _e === void 0 ? ['#15e8b5', '#4fa1f9'] : _e,\n      _f = _a.intro,\n      intro = _f === void 0 ? 'Hold to talk' : _f,\n      _g = _a.hint,\n      hint = _g === void 0 ? 'Hold to talk' : _g,\n      fontSize = _a.fontSize,\n      showTime = _a.showTime,\n      textColor = _a.textColor,\n      backgroundColor = _a.backgroundColor,\n      placement = _a.placement,\n      voffset = _a.voffset,\n      _h = _a.tapToTalkTime,\n      tapToTalkTime = _h === void 0 ? 8000 : _h,\n      _j = _a.silenceToHangupTime,\n      silenceToHangupTime = _j === void 0 ? 1000 : _j;\n\n  var _k = (0, react_client_1.useSpeechContext)(),\n      speechState = _k.speechState,\n      toggleRecording = _k.toggleRecording,\n      initialise = _k.initialise,\n      segment = _k.segment;\n\n  var _l = (0, react_1.useState)(false),\n      loaded = _l[0],\n      setLoaded = _l[1];\n\n  var _m = (0, react_1.useState)(powerOn ? react_client_1.SpeechState.Idle : react_client_1.SpeechState.Ready),\n      icon = _m[0],\n      setIcon = _m[1];\n\n  var _o = (0, react_1.useState)(intro),\n      hintText = _o[0],\n      setHintText = _o[1];\n\n  var _p = (0, react_1.useState)(true),\n      showHint = _p[0],\n      setShowHint = _p[1];\n\n  var buttonStateRef = (0, react_1.useRef)({\n    tapListenActive: false,\n    tapListenTimeout: null\n  });\n  var buttonRef = (0, react_1.useRef)();\n  var speechStateRef = (0, react_1.useRef)();\n  var TAP_TRESHOLD_MS = 600; // make stateRef always have the current count\n  // your \"fixed\" callbacks can refer to this object whenever\n  // they need the current value.  Note: the callbacks will not\n  // be reactive - they will not re-run the instant state changes,\n  // but they *will* see the current value whenever they do run\n\n  speechStateRef.current = speechState; // Dynamic import of HTML custom element to play nice with Next.js SSR\n\n  (0, react_1.useEffect)(function () {\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    (function () {\n      return __awaiter(void 0, void 0, void 0, function () {\n        var import1, import2;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              import1 = Promise.resolve().then(function () {\n                return __importStar(require('@speechly/browser-ui/core/holdable-button'));\n              });\n              import2 = Promise.resolve().then(function () {\n                return __importStar(require('@speechly/browser-ui/core/call-out'));\n              });\n              return [4\n              /*yield*/\n              , Promise.all([import1, import2])];\n\n            case 1:\n              _a.sent();\n\n              setLoaded(true);\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    })();\n  }, []);\n  (0, react_1.useEffect)(function () {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (buttonRef === null || buttonRef === void 0 ? void 0 : buttonRef.current) {\n      var button = buttonRef.current;\n      button.onholdstart = tangentPressAction;\n      button.onholdend = tangentReleaseAction;\n    }\n  });\n  (0, react_1.useEffect)(function () {\n    var _a; // Change button face according to Speechly states\n\n\n    if (!powerOn && speechState === react_client_1.SpeechState.Idle) {\n      setIcon(react_client_1.SpeechState.Ready);\n    } else {\n      setIcon(speechState);\n    } // Automatically start recording if button held\n\n\n    if (!powerOn && (((_a = buttonRef === null || buttonRef === void 0 ? void 0 : buttonRef.current) === null || _a === void 0 ? void 0 : _a.isbuttonpressed()) === true || buttonStateRef.current.tapListenActive) && speechState === react_client_1.SpeechState.Ready) {\n      toggleRecording().catch(function (err) {\n        return console.error('Error while starting to record', err);\n      });\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [speechState]);\n\n  var tangentPressAction = function () {\n    pubsub_js_1.default.publish(types_1.SpeechlyUiEvents.TangentPress, {\n      state: speechStateRef.current\n    });\n    window.postMessage({\n      type: 'holdstart',\n      state: (0, types_1.mapSpeechStateToClientState)(speechStateRef.current !== undefined ? speechStateRef.current : react_client_1.SpeechState.Idle)\n    }, '*');\n    setShowHint(false);\n\n    if (buttonStateRef.current.tapListenTimeout) {\n      window.clearTimeout(buttonStateRef.current.tapListenTimeout);\n      buttonStateRef.current.tapListenTimeout = null;\n    }\n\n    switch (speechStateRef.current) {\n      case react_client_1.SpeechState.Idle:\n      case react_client_1.SpeechState.Failed:\n        // Speechly & Mic initialise needs to be in a function triggered by event handler\n        // otherwise it won't work reliably on Safari iOS as of 11/2020\n        initialise().catch(function (err) {\n          return console.error('Error initiasing Speechly', err);\n        });\n        break;\n\n      case react_client_1.SpeechState.Ready:\n        toggleRecording().catch(function (err) {\n          return console.error('Error while starting to record', err);\n        });\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  var tangentReleaseAction = function (event) {\n    pubsub_js_1.default.publish(types_1.SpeechlyUiEvents.TangentRelease, {\n      state: speechStateRef.current,\n      timeMs: event.timeMs\n    });\n    window.postMessage({\n      type: 'holdend'\n    }, '*');\n\n    if (event.timeMs < TAP_TRESHOLD_MS) {\n      if (tapToTalkTime === 0) {\n        setHintText(hint);\n        setShowHint(true);\n      } else {\n        // Short press when not recording = schedule \"silence based stop\"\n        if (!buttonStateRef.current.tapListenActive) {\n          setStopContextTimeout(tapToTalkTime);\n        }\n      }\n    }\n\n    if (!buttonStateRef.current.tapListenTimeout) {\n      stopListening();\n    }\n  };\n\n  var setStopContextTimeout = function (timeoutMs) {\n    if (isStoppable(speechState)) {\n      buttonStateRef.current.tapListenActive = true;\n\n      if (buttonStateRef.current.tapListenTimeout) {\n        window.clearTimeout(buttonStateRef.current.tapListenTimeout);\n      }\n\n      buttonStateRef.current.tapListenTimeout = window.setTimeout(function () {\n        buttonStateRef.current.tapListenTimeout = null;\n        stopListening();\n      }, timeoutMs);\n    }\n  };\n\n  var stopListening = function () {\n    buttonStateRef.current.tapListenActive = false;\n\n    if (isStoppable(speechStateRef.current)) {\n      toggleRecording().catch(function (err) {\n        return console.error('Error while stopping recording', err);\n      });\n    }\n  };\n  /**\n   * Extend listening time if segment updates received\n   */\n\n\n  (0, react_1.useEffect)(function () {\n    if (segment) {\n      if (buttonStateRef.current.tapListenTimeout) {\n        setStopContextTimeout(silenceToHangupTime);\n      }\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [segment]);\n\n  var isStoppable = function (s) {\n    return s === react_client_1.SpeechState.Recording;\n  };\n\n  if (!loaded) return null;\n  return react_1.default.createElement(\"div\", null, placement === 'bottom' && react_1.default.createElement(__1.PushToTalkButtonContainer, {\n    size: size,\n    voffset: voffset\n  }, react_1.default.createElement(\"holdable-button\", {\n    ref: buttonRef,\n    poweron: powerOn,\n    capturekey: captureKey,\n    icon: icon,\n    size: size,\n    gradientstop1: gradientStops[0],\n    gradientstop2: gradientStops[1],\n    hide: hide ? 'true' : 'false'\n  }), react_1.default.createElement(\"call-out\", {\n    show: showHint && hintText !== '',\n    fontsize: fontSize,\n    textcolor: textColor,\n    backgroundcolor: backgroundColor,\n    showtime: showTime\n  }, hintText)), placement !== 'bottom' && react_1.default.createElement(react_1.default.Fragment, null, react_1.default.createElement(\"holdable-button\", {\n    ref: buttonRef,\n    poweron: powerOn,\n    capturekey: captureKey,\n    icon: icon,\n    size: size,\n    gradientstop1: gradientStops[0],\n    gradientstop2: gradientStops[1],\n    hide: hide ? 'true' : 'false'\n  }), react_1.default.createElement(\"call-out\", {\n    show: showHint && hintText !== '',\n    fontsize: fontSize,\n    textcolor: textColor,\n    backgroundcolor: backgroundColor,\n    showtime: showTime\n  }, hintText)));\n};\n\nexports.PushToTalkButton = PushToTalkButton;","map":{"version":3,"mappings":"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","names":["PushToTalkButton","_a","_b","powerOn","_c","hide","captureKey","_d","size","_e","gradientStops","_f","intro","_g","hint","fontSize","showTime","textColor","backgroundColor","placement","voffset","_h","tapToTalkTime","_j","silenceToHangupTime","speechState","toggleRecording","initialise","segment","loaded","setLoaded","react_client_1","Idle","Ready","icon","setIcon","hintText","setHintText","showHint","setShowHint","buttonStateRef","tapListenActive","tapListenTimeout","buttonRef","speechStateRef","TAP_TRESHOLD_MS","current","import1","import2","Promise","all","button","onholdstart","tangentPressAction","onholdend","tangentReleaseAction","isbuttonpressed","catch","error","err","pubsub_js_1","publish","types_1","TangentPress","state","window","postMessage","type","undefined","clearTimeout","Failed","event","TangentRelease","timeMs","setStopContextTimeout","stopListening","timeoutMs","isStoppable","setTimeout","s","Recording","react_1","__1","ref","poweron","capturekey","gradientstop1","gradientstop2","show","fontsize","textcolor","backgroundcolor","showtime","exports"],"sources":["/react-ui/src/components/PushToTalkButton.tsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react'\nimport { ClientState, useSpeechContext } from '@speechly/react-client'\nimport PubSub from 'pubsub-js'\nimport { SpeechlyUiEvents } from '../types'\nimport { PushToTalkButtonContainer } from '..'\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  namespace JSX {\n    interface IntrinsicElements {\n      'holdable-button': any\n    }\n    interface IntrinsicElements {\n      'call-out': any\n    }\n  }\n}\n\n/**\n * Properties for PushToTalkButton component.\n *\n * @public\n */\nexport type PushToTalkButtonProps = {\n  /**\n   * Optional \"bottom\" string turns on internal placement without any CSS positioning.\n   */\n  placement?: string\n\n  /**\n   * Keyboard key to use for controlling the button.\n   * Passing e.g. ` ` (a spacebar) will mean that holding down the spacebar key will key the button pressed.\n   */\n  captureKey?: string\n\n  /**\n   * The size of the button, as CSS (e.g. `5rem`).\n   */\n  size?: string\n\n  /**\n   * Colours of the gradient around the button.\n   * Valid input is an array of two hex colour codes, e.g. `['#fff', '#000']`.\n   */\n  gradientStops?: string[]\n\n  /**\n   * Optional boolean. Default: false\n   */\n  hide?: boolean\n\n  /**\n   * Optional string containing a short usage introduction. Displayed when the component is first displayed. Default: \"Push to talk\". Set to \"\" to disable.\n   */\n  intro?: string\n\n  /**\n   * Optional string containing a short usage hint. Displayed on a short tap. Default: \"Push to talk\". Set to \"\" to disable.\n   */\n  hint?: string\n\n  /**\n   * Optional CSS string for hint text. Default: \"1.2rem\"\n   */\n  fontSize?: string\n\n  /**\n   * Optional number in ms. Visibility duration for intro and hint callouts. Default: \"5000\" (ms)\n   */\n  showTime?: number\n\n  /**\n   * Optional string (CSS color) for hint text. Default: \"#ffffff\"\n   */\n  textColor?: string\n\n  /**\n   * Optional string (CSS color) for hint text background. Default: \"#202020\"\n   */\n  backgroundColor?: string\n\n  /**\n   * Optional boolean. Shows poweron state. If false, recording can immediately start but will first press will cause a system permission prompt. Default: false\n   */\n  powerOn?: boolean\n\n  /**\n   * Optional CSS string. Vertical distance from viewport edge. Only effective when using placement.\n   */\n  voffset?: string\n\n  /**\n   * Optional time in milliseconds to listen after tap. Set to 0 to disable tap-to-talk. Default: \"8000\" (ms)\n   */\n  tapToTalkTime?: number\n\n  /**\n   * Optional milliseconds of silence to listen before hangup. Only used in tap-to-talk mode. Default: \"1000\" (ms)\n   */\n  silenceToHangupTime?: number\n\n}\n\n/**\n * A React component that renders a push-to-talk microphone button.\n *\n * Make sure to place this component inside your `SpeechProvider` component imported from `@speechly/react-client`.\n *\n * @public\n */\n\ntype IButtonState = {\n  tapListenActive: boolean\n  holdListenActive: boolean\n  tapListenTimeout: number | null\n  tangentPressPromise: Promise<void> | null\n}\n\nexport const PushToTalkButton: React.FC<PushToTalkButtonProps> = ({\n  powerOn = false,\n  hide = false,\n  captureKey,\n  size = '6.0rem',\n  gradientStops = ['#15e8b5', '#4fa1f9'],\n  intro = 'Hold to talk',\n  hint = 'Hold to talk',\n  fontSize,\n  showTime,\n  textColor,\n  backgroundColor,\n  placement,\n  voffset,\n  tapToTalkTime = 8000,\n  silenceToHangupTime = 1000,\n}) => {\n  const { clientState, initialise, startContext, stopContext, segment } = useSpeechContext()\n  const [loaded, setLoaded] = useState(false)\n  const [icon, setIcon] = useState<string>((powerOn ? ClientState.Disconnected : ClientState.Connected) as unknown as string)\n  const [hintText, setHintText] = useState<string>(intro)\n  const [showHint, setShowHint] = useState(true)\n  const buttonStateRef = useRef<IButtonState>({\n    tapListenActive: false,\n    holdListenActive: false,\n    tapListenTimeout: null,\n    tangentPressPromise: null,\n  })\n  const buttonRef = useRef<any>()\n  const clientStateRef = useRef<ClientState>()\n\n  const TAP_TRESHOLD_MS = 600\n  const PERMISSION_PRE_GRANTED_TRESHOLD_MS = 1500\n\n  // make stateRef always have the current count\n  // your \"fixed\" callbacks can refer to this object whenever\n  // they need the current value.  Note: the callbacks will not\n  // be reactive - they will not re-run the instant state changes,\n  // but they *will* see the current value whenever they do run\n  clientStateRef.current = clientState\n\n  // Dynamic import of HTML custom element to play nice with Next.js SSR\n  useEffect(() => {\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    (async () => {\n      const import1 = import('@speechly/browser-ui/core/holdable-button')\n      const import2 = import('@speechly/browser-ui/core/call-out')\n      await Promise.all([import1, import2])\n      setLoaded(true)\n    })()\n  }, [])\n\n  useEffect(() => {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (buttonRef?.current) {\n      const button = buttonRef.current\n      button.onholdstart = tangentPressAction\n      button.onholdend = tangentReleaseAction\n    }\n  })\n\n  useEffect(() => {\n    // Change button face according to Speechly states\n    if (!powerOn && clientState === ClientState.Disconnected) {\n      setIcon(ClientState.Connected as unknown as string)\n    } else {\n      setIcon(clientState as unknown as string)\n    }\n\n    // Automatically start recording if button held\n    if (!powerOn && (buttonStateRef.current.holdListenActive || buttonStateRef.current.tapListenActive) && clientStateRef.current === ClientState.Connected) {\n      startContext().catch(err => console.error('Error while starting to record', err))\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [clientState])\n\n  const tangentPressAction = async (): Promise<void> => {\n    buttonStateRef.current.tangentPressPromise = (async() => {\n      PubSub.publish(SpeechlyUiEvents.TangentPress, { state: clientStateRef.current })\n      window.postMessage({ type: 'holdstart', state: clientStateRef.current }, '*')\n      setShowHint(false)\n\n      if (buttonStateRef.current.tapListenTimeout) {\n        window.clearTimeout(buttonStateRef.current.tapListenTimeout)\n        buttonStateRef.current.tapListenTimeout = null\n      }\n\n      switch (clientStateRef.current) {\n        case ClientState.Disconnected:\n        case ClientState.Failed:\n          // Speechly & Mic initialise needs to be in a function triggered by event handler\n          // otherwise it won't work reliably on Safari iOS as of 11/2020\n          const initStartTime = Date.now()\n          await initialise().catch(err => console.error('Error initiasing Speechly', err))\n          // await buttonStateRef.current.initPromise\n          // Long init time suggests permission dialog --> prevent listening start\n          buttonStateRef.current.holdListenActive = !powerOn && Date.now() - initStartTime < PERMISSION_PRE_GRANTED_TRESHOLD_MS\n          break\n        default:\n          buttonStateRef.current.holdListenActive = true\n          break\n      }\n\n      // Start listening\n      if (buttonStateRef.current.holdListenActive) {\n        if (clientStateRef.current === ClientState.Connected) {\n          await startContext().catch(err => console.error('Error while starting to record', err))\n        }\n      }\n    })()\n  }\n\n  const tangentReleaseAction = async (event: any): Promise<void> => {\n    // Ensure async tangentPress and Release are run in appropriate order\n    await buttonStateRef.current.tangentPressPromise\n\n    PubSub.publish(SpeechlyUiEvents.TangentRelease, { state: clientStateRef.current, timeMs: event.timeMs })\n    window.postMessage({ type: 'holdend' }, '*')\n\n    if (buttonStateRef.current.holdListenActive) {\n      buttonStateRef.current.holdListenActive = false\n\n      if (event.timeMs < TAP_TRESHOLD_MS) {\n        if (tapToTalkTime === 0) {\n          setHintText(hint)\n          setShowHint(true)\n        } else {\n          // Short press when not recording = schedule \"silence based stop\"\n          if (!buttonStateRef.current.tapListenActive) {\n            setStopContextTimeout(tapToTalkTime)\n          }\n        }\n      }\n\n      if (!buttonStateRef.current.tapListenTimeout) {\n        stopListening()\n      }\n    }\n  }\n\n  const setStopContextTimeout = (timeoutMs: number): void => {\n    buttonStateRef.current.tapListenActive = true\n    if (buttonStateRef.current.tapListenTimeout) {\n      window.clearTimeout(buttonStateRef.current.tapListenTimeout)\n    }\n    buttonStateRef.current.tapListenTimeout = window.setTimeout(() => {\n      buttonStateRef.current.tapListenTimeout = null\n      stopListening()\n    }, timeoutMs)\n  }\n\n  const stopListening = (): void => {\n    buttonStateRef.current.tapListenActive = false\n    if (isStoppable(clientStateRef.current)) {\n      stopContext().catch(err => console.error('Error while stopping recording', err))\n    }\n  }\n\n  /**\n   * Extend listening time if segment updates received\n   */\n  useEffect(() => {\n    if (segment) {\n      if (buttonStateRef.current.tapListenTimeout) {\n        setStopContextTimeout(silenceToHangupTime)\n      }\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [segment])\n\n  const isStoppable = (s?: ClientState): boolean => {\n    return (s === ClientState.Recording)\n  }\n\n  if (!loaded) return null\n\n  return (\n    <div>\n      { (placement === 'bottom') && (\n        <PushToTalkButtonContainer size={size} voffset={voffset}>\n          <holdable-button ref={buttonRef} poweron={powerOn} capturekey={captureKey} icon={icon} size={size} gradientstop1={gradientStops[0]} gradientstop2={gradientStops[1]} hide={hide ? 'true' : 'false'}></holdable-button>\n          <call-out show={showHint && hintText !== ''} fontsize={fontSize} textcolor={textColor} backgroundcolor={backgroundColor} showtime={showTime}>{hintText}</call-out>\n        </PushToTalkButtonContainer>\n      )}\n      { (placement !== 'bottom') && (\n        <>\n          <holdable-button ref={buttonRef} poweron={powerOn} capturekey={captureKey} icon={icon} size={size} gradientstop1={gradientStops[0]} gradientstop2={gradientStops[1]} hide={hide ? 'true' : 'false'}></holdable-button>\n          <call-out show={showHint && hintText !== ''} fontsize={fontSize} textcolor={textColor} backgroundcolor={backgroundColor} showtime={showTime}>{hintText}</call-out>\n        </>\n      )}\n    </div>\n  )\n}\n"]},"metadata":{},"sourceType":"script"}